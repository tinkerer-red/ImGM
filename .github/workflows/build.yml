name: Build
run-name: "Build - GM Runtime ${{ inputs.runtime }}"

on:
    workflow_dispatch:
        inputs:
            runtime:
                description: "Target runtime"
                default: "2024.13.1.242"
                required: false
    workflow_call:
        inputs:
            runtime:
                description: "Target runtime"
                default: "2024.13.1.242"
                required: false
                type: string
permissions:
    contents: write
env:
    PROJECT_NAME: "ImGM"
    CMAKE_VERSION: "4.1.1"
    NODE_VERSION: "20"
    PREMAKE_VERSION: "5.0.0-beta2"
    DLL_PATH: "${{ github.workspace }}/src/gm/ImGM/extensions/ImGM"
    YYP_PATH: "${{ github.workspace }}/src/gm/ImGM/ImGM.yyp"

jobs:
    build-imgm:
        strategy:
            matrix:
                os: [windows-latest] # TODO: ignored for now: ubuntu-latest, macos-latest
        runs-on: ${{ matrix.os }}
        name: Build ImGM (${{ matrix.os }})
        environment: GameMaker
        outputs:
            igor-user-dir: ${{ steps.igor-0.outputs.user-dir }}
            igor-runtime-dir: ${{ steps.igor-0.outputs.runtime-dir }}
        steps:
            #region Init
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  submodules: recursive

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}

            - name: Install Dependencies
              run: |
                  npm ci
                  pip install -r requirements.txt

            - name: Setup CMake
              uses: jwlawson/actions-setup-cmake@v2
              with:
                  cmake-version: ${{ env.CMAKE_VERSION }}

            - name: Setup Premake
              uses: abel0b/setup-premake@v2.4
              with:
                  version: ${{ env.PREMAKE_VERSION }}
            #endregion

            #region Setup
            - name: Get YYP version from file (Linux)
              if: runner.os == 'Linux'
              run: |
                  echo "YYP_VERSION=$(grep -oP '(?<=IDEVersion":")(\d+\.\d+\.\d+\.\d+)(?=")' ${{ env.YYP_PATH }})" >> $GITHUB_ENV
            - name: Get YYP version from file (Windows)
              if: runner.os == 'Windows'
              run: |
                  $yypVersion = Select-String -Path "${{ env.YYP_PATH }}" -Pattern 'IDEVersion":"(\d+\.\d+\.\d+\.\d+)' -AllMatches | ForEach-Object { $_.Matches.Groups[1].Value }
                  "YYP_VERSION=$yypVersion" | Out-File -Append -FilePath $env:GITHUB_ENV

            - name: Igor Setup
              # Needed for using ImGM toolchain (for modules:copy below if using --gm)
              uses: bscotch/igor-setup@main
              timeout-minutes: 20
              id: igor-0
              with:
                  target-yyp: ${{ env.YYP_PATH }}
                  access-key: ${{ secrets.ACCESS_KEY }}
                  local-settings-override-file: ${{ github.workspace }}/local_settings.json
                  runtime-version: ${{ inputs.runtime }}
                  cache: true

            - name: Caching
              uses: actions/cache@v4
              with:
                  path: |
                      ${{ env.YYP_PATH }}
                  key: OS-${{ runner.os }}-_-GM-${{ inputs.runtime }}

            #endregion

            #region Process
            - name: Store Directory into Environment
              run: |
                  echo "IGOR_USER_DIR=${{ steps.igor-0.outputs.user-dir }}" >> $GITHUB_ENV
                  echo "GM_RUNTIME=${{ steps.igor-0.outputs.runtime-dir }}" >> $GITHUB_ENV

            - name: ImGM Run modules:copy
              run: npm run modules:copy -- --imgui --ext all
              env:
                  GM_RUNTIME: ${{ steps.igor-0.outputs.runtime-dir }}

            - name: Run Premake
              run: |
                  if ($env:RUNNER_OS -eq "Windows") {
                    premake5 vs2022
                    cmake-converter.exe -s ./src/dll/dll.sln
                  } else {
                    premake5 gmake2
                  }

            - name: Configure CMake
              run: |
                  cmake -S src/dll -B src/dll/build-debug -DCMAKE_BUILD_TYPE=Debug
                  cmake -S src/dll -B src/dll/build-release -DCMAKE_BUILD_TYPE=Release

            - name: Build Debug
              run: |
                  cmake --build src/dll/build-debug
                  if ($env:RUNNER_OS -eq "Windows") {
                    $files = @("ImGM.dll", "ImGM.exp", "ImGM.lib", "ImGM.pdb", "ImGM.so", "ImGM.dylib")
                    $base = "${{ env.DLL_PATH }}"
                    foreach ($file in $files) {
                      $src = Join-Path $base $file
                      $newName = "{0}.debug{1}" -f [System.IO.Path]::GetFileNameWithoutExtension($file), [System.IO.Path]::GetExtension($file)
                      $dst = Join-Path $base $newName
                      if (Test-Path $src) {
                          try {
                            Rename-Item -Path $src -NewName $newName
                            Write-Host "Renamed $file to $newName"
                          } catch {
                            Write-Host "Failed to rename $src ‚Üí $newName"
                            Write-Host "Error: $_"
                          }
                        } else {
                          Write-Host "Skipping file not found: $src"
                        }
                    }
                  } else {
                    $base = "${{ env.DLL_PATH }}"
                    $files = @("ImGM.so", "ImGM.dylib")
                    foreach ($file in $files) {
                      $src = Join-Path $base $file
                      $nameOnly = $file.Substring(0, $file.LastIndexOf('.'))
                      $ext = $file.Split('.')[-1]
                      $newName = "$nameOnly.debug.$ext"
                      $dst = Join-Path $base $newName

                      if (Test-Path $src) {
                          try {
                            Rename-Item -Path $src -NewName $newName
                            Write-Host "Renamed $file to $newName"
                          } catch {
                            Write-Host "Failed to rename $src ‚Üí $newName"
                            Write-Host "Error: $_"
                          }
                        } else {
                          Write-Host "Skipping file not found: $src"
                        }

                    }
                  }

            - name: Build Release
              run: cmake --build src/dll/build-release

            - name: Upload Debug DLLs
              uses: actions/upload-artifact@v4
              with:
                  name: ImGM-Debug-${{ matrix.os }}
                  path: ${{ env.DLL_PATH }}/ImGM.debug.*
                  retention-days: 1
            - name: Upload Release DLLs
              uses: actions/upload-artifact@v4
              with:
                  name: ImGM-Release-${{ matrix.os }}
                  path: ${{ env.DLL_PATH }}/ImGM.*
                  retention-days: 1
            #endregion

    test-imgm:
        needs: build-imgm
        strategy:
            fail-fast: false
            matrix:
                os: [windows-latest] # TODO: ignored for now: ubuntu-latest, macos-latest
        runs-on: ${{ matrix.os }}
        name: Test ImGM (${{ matrix.os }}) - GM Runtime ${{ inputs.runtime }}
        environment: GameMaker
        env:
            IGOR_USER_DIR: ${{ needs.build-imgm.outputs.igor-user-dir }}
            GM_RUNTIME: ${{ needs.build-imgm.outputs.igor-runtime-dir }}
        steps:
            #region Init
            - name: Checkout
              uses: actions/checkout@v4

            - name: Download Debug DLLs
              uses: actions/download-artifact@v4
              with:
                  name: ImGM-Debug-${{ matrix.os }}
                  path: ${{ env.DLL_PATH }}/debug

            - name: Download Release DLLs
              uses: actions/download-artifact@v4
              with:
                  name: ImGM-Release-${{ matrix.os }}
                  path: ${{ env.DLL_PATH }}/release

            - name: Restore DLLs to Original Paths
              shell: pwsh
              run: |
                  $base = "${{ env.DLL_PATH }}"
                  $debugDir = Join-Path $base "debug"
                  $releaseDir = Join-Path $base "release"
                  $files = @("ImGM.dll", "ImGM.exp", "ImGM.lib", "ImGM.pdb", "ImGM.so", "ImGM.dylib")
                  foreach ($file in $files) {
                    $debug = Join-Path $debugDir $file
                    $release = Join-Path $releaseDir $file
                    $target = Join-Path $base $file
                    if (Test-Path $release) {
                      Write-Host "Moving $file (Release) to $base"
                      Copy-Item $release -Destination $target -Force
                    }
                    elseif (Test-Path $debug) {
                      Write-Host "Moving $file (Debug) to $base"
                      Copy-Item $debug -Destination $target -Force
                    } else {
                      Write-Host "Skipping file not found: $file"
                    }
                  }
            #endregion
            #region Build
            - name: Igor Setup
              uses: bscotch/igor-setup@main
              timeout-minutes: 20
              id: igor
              with:
                  target-yyp: ${{ env.YYP_PATH }}
                  access-key: ${{ secrets.ACCESS_KEY }}
                  local-settings-override-file: ${{ github.workspace }}/local_settings.json
                  runtime-version: ${{ inputs.runtime }}
                  cache: true
            - name: Igor Build
              uses: bscotch/igor-build@main
              timeout-minutes: 20
              id: igor-build
              with:
                  yyp-path: ${{ env.YYP_PATH }}
                  user-dir: ${{ env.IGOR_USER_DIR }}
                  config: Test

            - name: Upload Output Application
              uses: actions/upload-artifact@v4
              with:
                  name: igor-build-${{ matrix.os }}
                  path: ${{ steps.igor-build.outputs.out-dir }}
                  retention-days: 1
            #endregion
            #region Perform tests
            - name: Test Application
              if: runner.os == 'Windows'
              timeout-minutes: 20
              shell: pwsh
              working-directory: ${{ steps.igor-build.outputs.out-dir }}
              run: |
                  $baseName = "${{ env.PROJECT_NAME }}"
                  Expand-Archive -Path ${{ steps.igor-build.outputs.out-dir }}/$baseName.zip -Destination ${{ steps.igor-build.outputs.out-dir }}
                  $saveDataDir = Join-Path $env:LOCALAPPDATA $baseName

                  $executableName = "${{ env.PROJECT_NAME }}"
                  $exePath = Resolve-Path "$executableName.exe"
                  if (-not (Test-Path $exePath)) {
                      throw "$exePath does not exist"
                  }

                  $logFile = "run.log"
                  if ((Test-Path $logFile)) {
                    Remove-Item $logFile -Force
                  }
                  New-Item -Path $logFile -ItemType File -Force
                  $logFile = Resolve-Path $logFile

                  $ktfLog = "ktf-stats.log"
                  if (Test-Path $ktfLog) {
                      Remove-Item $ktfLog -Force
                  }

                  Write-Host "Running $exePath"
                  $process = Start-Process -FilePath $exePath -ArgumentList "-output","$logFile","-debugoutput","$logFile" -PassThru -NoNewWindow

                  if ((Test-Path $saveDataDir)) {
                    Remove-Item $saveDataDir -Recurse -Force
                  }

                  Write-Host "Testing..."
                  $maxWaitSeconds = 600
                  $startTime = Get-Date
                  $done = $false

                  while (-not $done -and ((Get-Date) - $startTime).TotalSeconds -lt $maxWaitSeconds) {
                      Start-Sleep -Seconds 1
                      if (Test-Path $ktfLog) {
                          try {
                              $json = Get-Content $ktfLog -Raw | ConvertFrom-Json
                              if ($json.status -eq "done") {
                                  $done = $true
                                  Write-Host "‚úÖ Test run complete"
                                  Write-Host "‚úî Passed: $($json.success)"
                                  Write-Host "‚ùå Failed: $($json.failed)"
                                  Write-Host "üìä Total: $($json.count)"
                              } else {
                                  Write-Host "‚è≥ Status: $($json.status)"
                                  foreach ($testName in $json.tests.Keys) {
                                      $test = $json.tests[$testName]
                                      $status = $test._status
                                      $assertions = $test.assertions
                                      Write-Host "‚Ä¢ $testName ‚Üí $status ($assertions assertions)"
                                  }
                              }
                          } catch {
                              Write-Host "‚ö†Ô∏è Failed to parse ktf-stats.log: $_"
                          }
                      } else {
                          Write-Host "‚è≥ Waiting for ktf-stats.log..."
                      }
                  }

                  Wait-Process -InputObject $process
                  if ($process.ExitCode -ne 0 -or -not $done) {
                      Write-Host "‚ùå Test application failed or timed out"
                      exit 1
                  }

                  Write-Host "‚úÖ All tests passed"
                  exit 0
              #endregion
